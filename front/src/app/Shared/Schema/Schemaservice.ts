/**
* NOTE: This class is auto generated by the template angular2-typescript-service.cshtml.
* Do not edit the class manually.
*/

import { Inject, Injectable, Optional } from '@angular/core';
import { Http, Headers, URLSearchParams } from '@angular/http';
import { RequestMethod, RequestOptions, RequestOptionsArgs } from '@angular/http';
import { Response, ResponseContentType } from '@angular/http';
import { Observable } from 'rxjs/Observable';
import { BASE_PATH } from '../variables';
import { Configuration } from '../configuration.model';
import { ApplicationStructure } from '../SchemaApi/Models/Structures/ApplicationStructure';

@Injectable()export class Schema {
   protected basePath: string = 'http://petstore.swagger.io/v2';
   public defaultHeaders: Headers = new Headers();
   public configuration: Configuration = new Configuration();
   constructor(protected http : Http, @Optional() @Inject(BASE_PATH) basePath : string, @Optional() configuration : Configuration) {
      if (basePath) {
         this.basePath = basePath;
      }
      if (configuration) {
         this.configuration = configuration;
      }
   }

       /**
    *
    * Extends object by coping non-existing properties.
    * @@param objA object to be extended
    * @@param objB source object
    */
    private extendObj<T1, T2>
        (objA: T1, objB: T2) {
        for (let key in objB) {
            if (objB.hasOwnProperty(key)) {
                (objA as any)[key] = (objB as any)[key];
            }
        }
        return <T1 & T2>
            objA;
    }

    /**
    * @@param consumes string[] mime-types
    * @@return true: consumes contains 'multipart/form-data', false: otherwise
    */
    private canConsumeForm(consumes: string[]): boolean {
        const form = 'multipart/form-data';
        for (let consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }

   public GetList() : Observable<Array<String>> {
      return this.GetList_WithHttpInfo()
      .map((response: Response) =>  {
         if (response.status === 204) {
            return undefined;
         }
         else {
            return response.json() || { };
         }
      }
      );
   }
   private GetList_WithHttpInfo(extraHttpRequestParams? : any) : Observable<Response> {

      const path = this.basePath + '/api/Schema/list';

      let queryParameters = new URLSearchParams();
      let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
      let body : string = '';

      // to determine the Accept header
      let produces: string[] = [ 'application/xml', 'application/json' ];
      headers.set('Content-Type', 'application/json');

      let requestOptions: RequestOptionsArgs = new RequestOptions({
       headers: headers,
       method: RequestMethod.Get,
       body:'',
       search: queryParameters,
       withCredentials: this.configuration.withCredentials
      });

      if (extraHttpRequestParams) {
         requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
      }
      return this.http.request(path, requestOptions);
   }

   public Get(applicationName : String) : Observable<ApplicationStructure> {
      return this.Get_WithHttpInfo(applicationName)
      .map((response: Response) =>  {
         if (response.status === 204) {
            return undefined;
         }
         else {
            return response.json() || { };
         }
      }
      );
   }
   private Get_WithHttpInfo(applicationName : String, extraHttpRequestParams? : any) : Observable<Response> {

      const path = this.basePath + '/api/Schema/detail/{applicationName}';

      let queryParameters = new URLSearchParams();
      let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
      let body : string = '';

      // to determine the Accept header
      let produces: string[] = [ 'application/xml', 'application/json' ];
      if (applicationName !== undefined) {
         queryParameters.set('applicationName', <any> applicationName);
      }

      headers.set('Content-Type', 'application/json');

      let requestOptions: RequestOptionsArgs = new RequestOptions({
       headers: headers,
       method: RequestMethod.Get,
       body:'',
       search: queryParameters,
       withCredentials: this.configuration.withCredentials
      });

      if (extraHttpRequestParams) {
         requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
      }
      return this.http.request(path, requestOptions);
   }

   public Post(application : ApplicationStructure, lockid : String) : Observable<{}> {
      return this.Post_WithHttpInfo(application, lockid)
      .map((response: Response) =>  {
         if (response.status === 204) {
            return undefined;
         }
         else {
            return response.json() || { };
         }
      }
      );
   }
   private Post_WithHttpInfo(application : ApplicationStructure, lockid : String, extraHttpRequestParams? : any) : Observable<Response> {

      const path = this.basePath + '/api/Schema/save/{lockid}';

      let queryParameters = new URLSearchParams();
      let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
      let body : string = '';

      // to determine the Accept header
      let produces: string[] = [ 'application/xml', 'application/json' ];
      if (application !== undefined) {
         body = JSON.stringify(application);
      }

      if (lockid !== undefined) {
         queryParameters.set('lockid', <any> lockid);
      }

      headers.set('Content-Type', 'application/json');

      let requestOptions: RequestOptionsArgs = new RequestOptions({
       headers: headers,
       method: RequestMethod.Post,
       body: body == null ? '' : body, 
       search: queryParameters,
       withCredentials: this.configuration.withCredentials
      });

      if (extraHttpRequestParams) {
         requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
      }
      return this.http.request(path, requestOptions);
   }

   public Lock(applicationName : String) : Observable<String> {
      return this.Lock_WithHttpInfo(applicationName)
      .map((response: Response) =>  {
         if (response.status === 204) {
            return undefined;
         }
         else {
            return response.json() || { };
         }
      }
      );
   }
   private Lock_WithHttpInfo(applicationName : String, extraHttpRequestParams? : any) : Observable<Response> {

      const path = this.basePath + '/api/Schema/lock';

      let queryParameters = new URLSearchParams();
      let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
      let body : string = '';

      // to determine the Accept header
      let produces: string[] = [ 'application/xml', 'application/json' ];
      if (applicationName !== undefined) {
         body = JSON.stringify(applicationName);
      }

      headers.set('Content-Type', 'application/json');

      let requestOptions: RequestOptionsArgs = new RequestOptions({
       headers: headers,
       method: RequestMethod.Get,
       body:'',
       search: queryParameters,
       withCredentials: this.configuration.withCredentials
      });

      if (extraHttpRequestParams) {
         requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
      }
      return this.http.request(path, requestOptions);
   }

   public UnLock(applicationName : String, lockid : String) : Observable<{}> {
      return this.UnLock_WithHttpInfo(applicationName, lockid)
      .map((response: Response) =>  {
         if (response.status === 204) {
            return undefined;
         }
         else {
            return response.json() || { };
         }
      }
      );
   }
   private UnLock_WithHttpInfo(applicationName : String, lockid : String, extraHttpRequestParams? : any) : Observable<Response> {

      const path = this.basePath + '/api/Schema/unlock/{lockid}';

      let queryParameters = new URLSearchParams();
      let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
      let body : string = '';

      // to determine the Accept header
      let produces: string[] = [ 'application/xml', 'application/json' ];
      if (applicationName !== undefined) {
         body = JSON.stringify(applicationName);
      }

      if (lockid !== undefined) {
         queryParameters.set('lockid', <any> lockid);
      }

      headers.set('Content-Type', 'application/json');

      let requestOptions: RequestOptionsArgs = new RequestOptions({
       headers: headers,
       method: RequestMethod.Get,
       body:'',
       search: queryParameters,
       withCredentials: this.configuration.withCredentials
      });

      if (extraHttpRequestParams) {
         requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
      }
      return this.http.request(path, requestOptions);
   }

   public Delete(applicationName : String, lockid : String) : Observable<{}> {
      return this.Delete_WithHttpInfo(applicationName, lockid)
      .map((response: Response) =>  {
         if (response.status === 204) {
            return undefined;
         }
         else {
            return response.json() || { };
         }
      }
      );
   }
   private Delete_WithHttpInfo(applicationName : String, lockid : String, extraHttpRequestParams? : any) : Observable<Response> {

      const path = this.basePath + '/api/Schema/{applicationName}/lockid';

      let queryParameters = new URLSearchParams();
      let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
      let body : string = '';

      // to determine the Accept header
      let produces: string[] = [ 'application/xml', 'application/json' ];
      if (applicationName !== undefined) {
         queryParameters.set('applicationName', <any> applicationName);
      }

      if (lockid !== undefined) {
         body = JSON.stringify(lockid);
      }

      headers.set('Content-Type', 'application/json');

      let requestOptions: RequestOptionsArgs = new RequestOptions({
       headers: headers,
       method: RequestMethod.Delete,
       body: '',
       search: queryParameters,
       withCredentials: this.configuration.withCredentials
      });

      if (extraHttpRequestParams) {
         requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
      }
      return this.http.request(path, requestOptions);
   }

}
