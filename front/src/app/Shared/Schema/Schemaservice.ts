/**
* NOTE: This class is auto generated by the template angular2-typescript-service.cshtml.
* Do not edit the class manually.
*/

import { Inject, Injectable, Optional } from '@angular/core';
import { Http, Headers, URLSearchParams } from '@angular/http';
import { RequestMethod, RequestOptions, RequestOptionsArgs } from '@angular/http';
import { Response, ResponseContentType } from '@angular/http';
import { Observable } from 'rxjs/Observable';
import { BASE_PATH } from '../variables';
import { Configuration } from '../configuration.model';
import { ApplicationStructure } from '../SchemaApi/Models/Structures/ApplicationStruct';

@Injectable()export class Schema {
   protected basePath: string = 'http://petstore.swagger.io/v2';
   public defaultHeaders: Headers = new Headers();
   public configuration: Configuration = new Configuration();
   constructor(protected http : Http, @Optional() @Inject(BASE_PATH) basePath : string, @Optional() configuration : Configuration) {
      if (basePath) {
         this.basePath = basePath;
      }
      if (configuration) {
         this.configuration = configuration;
      }
   }

       /**
    *
    * Extends object by coping non-existing properties.
    * @@param objA object to be extended
    * @@param objB source object
    */
    private extendObj<T1, T2>
        (objA: T1, objB: T2) {
        for (let key in objB) {
            if (objB.hasOwnProperty(key)) {
                (objA as any)[key] = (objB as any)[key];
            }
        }
        return <T1 & T2>
            objA;
    }

    /**
    * @@param consumes string[] mime-types
    * @@return true: consumes contains 'multipart/form-data', false: otherwise
    */
    private canConsumeForm(consumes: string[]): boolean {
        const form = 'multipart/form-data';
        for (let consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }

   public GetAll() : Observable<Array<String>> {
      return this.GetAll_WithHttpInfo()
      .map((response: Response) =>  {
         if (response.status === 204) {
            return undefined;
         }
         else {
            return response.json() || { };
         }
      }
      );
   }

   private GetAll_WithHttpInfo(extraHttpRequestParams? : any) : Observable<Response> {

      const path = this.basePath + '/api/Schema/index';

      let queryParameters = new URLSearchParams();
      let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
      // to determine the Accept header
      let produces: string[] = [ 'application/xml', 'application/json' ];
      headers.set('Content-Type', 'application/json');

      let requestOptions: RequestOptionsArgs = new RequestOptions({
       headers: headers,
       method: RequestMethod.Get,
       body:'',
       search: queryParameters,
       withCredentials: this.configuration.withCredentials
      });

      if (extraHttpRequestParams) {
         requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
      }
      return this.http.request(path, requestOptions);
   }

   public Get(applicationName : String) : Observable<ApplicationStructure> {
      return this.Get_WithHttpInfo(applicationName)
      .map((response: Response) =>  {
         if (response.status === 204) {
            return undefined;
         }
         else {
            return response.json() || { };
         }
      }
      );
   }

   private Get_WithHttpInfo(applicationName : String, extraHttpRequestParams? : any) : Observable<Response> {

      const path = this.basePath + '/api/Schema/detail/{applicationName}';

      let queryParameters = new URLSearchParams();
      let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

      // to determine the Accept header
      let produces: string[] = [ 'application/xml', 'application/json' ];
      if (applicationName !== undefined) {
         queryParameters.set('applicationName', <any> applicationName);
      }
      headers.set('Content-Type', 'application/json');

      let requestOptions: RequestOptionsArgs = new RequestOptions({
       headers: headers,
       method: RequestMethod.Get,
       body:'',
       search: queryParameters,
       withCredentials: this.configuration.withCredentials
      });

      if (extraHttpRequestParams) {
         requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
      }
      return this.http.request(path, requestOptions);
   }

   public Post(application : ApplicationStructure, lockId : String) : Observable<{}> {
      return this.Post_WithHttpInfo(application, lockId)
      .map((response: Response) =>  {
         if (response.status === 204) {
            return undefined;
         }
         else {
            return response.json() || { };
         }
      }
      );
   }

   private Post_WithHttpInfo(application : ApplicationStructure, lockId : String, extraHttpRequestParams? : any) : Observable<Response> {

      const path = this.basePath + '/api/Schema/save';

      let queryParameters = new URLSearchParams();
      let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845


      // to determine the Accept header
      let produces: string[] = [ 'application/xml', 'application/json' ];
      if (application !== undefined) {
         queryParameters.set('application', <any> application);
      }
      if (lockId !== undefined) {
         queryParameters.set('lockId', <any> lockId);
      }
      headers.set('Content-Type', 'application/json');

      let requestOptions: RequestOptionsArgs = new RequestOptions({
       headers: headers,
       method: RequestMethod.Post,
       body: body == null ? '' : JSON.stringify(body), // https://github.com/angular/angular/issues/10612
       search: queryParameters,
       withCredentials: this.configuration.withCredentials
      });

      if (extraHttpRequestParams) {
         requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
      }
      return this.http.request(path, requestOptions);
   }

   public Lock(applicationName : String) : Observable<String> {
      return this.Lock_WithHttpInfo(applicationName)
      .map((response: Response) =>  {
         if (response.status === 204) {
            return undefined;
         }
         else {
            return response.json() || { };
         }
      }
      );
   }

   private Lock_WithHttpInfo(applicationName : String, extraHttpRequestParams? : any) : Observable<Response> {

      const path = this.basePath + '/api/Schema/lock';

      let queryParameters = new URLSearchParams();
      let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

      // to determine the Accept header
      let produces: string[] = [ 'application/xml', 'application/json' ];
      if (applicationName !== undefined) {
         queryParameters.set('applicationName', <any> applicationName);
      }
      headers.set('Content-Type', 'application/json');

      let requestOptions: RequestOptionsArgs = new RequestOptions({
       headers: headers,
       method: RequestMethod.Get,
       body:'',
       search: queryParameters,
       withCredentials: this.configuration.withCredentials
      });

      if (extraHttpRequestParams) {
         requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
      }
      return this.http.request(path, requestOptions);
   }

   public UnLock(applicationName : String) : Observable<{}> {
      return this.UnLock_WithHttpInfo(applicationName)
      .map((response: Response) =>  {
         if (response.status === 204) {
            return undefined;
         }
         else {
            return response.json() || { };
         }
      }
      );
   }

   private UnLock_WithHttpInfo(applicationName : String, extraHttpRequestParams? : any) : Observable<Response> {

      const path = this.basePath + '/api/Schema/unlock';

      let queryParameters = new URLSearchParams();
      let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

      // to determine the Accept header
      let produces: string[] = [ 'application/xml', 'application/json' ];
      if (applicationName !== undefined) {
         queryParameters.set('applicationName', <any> applicationName);
      }
      headers.set('Content-Type', 'application/json');

      let requestOptions: RequestOptionsArgs = new RequestOptions({
       headers: headers,
       method: RequestMethod.Get,
       body:'',
       search: queryParameters,
       withCredentials: this.configuration.withCredentials
      });

      if (extraHttpRequestParams) {
         requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
      }
      return this.http.request(path, requestOptions);
   }

}
