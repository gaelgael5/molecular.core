/**
* NOTE: This class is auto generated by the template angular2-typescript-service.cshtml.
* Do not edit the class manually.
*/

import { Inject, Injectable, Optional } from '@angular/core';
import { Http, Headers, URLSearchParams } from '@angular/http';
import { RequestMethod, RequestOptions, RequestOptionsArgs } from '@angular/http';
import { Response, ResponseContentType } from '@angular/http';
import { Observable } from 'rxjs/Observable';
import { BASE_PATH } from '../variables';
import { Configuration } from '../configuration.model';
import { StoreServerData } from '../SchemaApi/Models/Stores/StoreServerData';

@Injectable()export class Store {
   protected basePath: string = 'http://petstore.swagger.io/v2';
   public defaultHeaders: Headers = new Headers();
   public configuration: Configuration = new Configuration();
   constructor(protected http : Http, @Optional() @Inject(BASE_PATH) basePath : string, @Optional() configuration : Configuration) {
      if (basePath) {
         this.basePath = basePath;
      }
      if (configuration) {
         this.configuration = configuration;
      }
   }

       /**
    *
    * Extends object by coping non-existing properties.
    * @@param objA object to be extended
    * @@param objB source object
    */
    private extendObj<T1, T2>
        (objA: T1, objB: T2) {
        for (let key in objB) {
            if (objB.hasOwnProperty(key)) {
                (objA as any)[key] = (objB as any)[key];
            }
        }
        return <T1 & T2>
            objA;
    }

    /**
    * @@param consumes string[] mime-types
    * @@return true: consumes contains 'multipart/form-data', false: otherwise
    */
    private canConsumeForm(consumes: string[]): boolean {
        const form = 'multipart/form-data';
        for (let consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }

   public List() : Observable<Array<String>> {
      return this.List_WithHttpInfo()
      .map((response: Response) =>  {
         if (response.status === 204) {
            return undefined;
         }
         else {
            return response.json() || { };
         }
      }
      );
   }
   private List_WithHttpInfo(extraHttpRequestParams? : any) : Observable<Response> {

      const path = this.basePath + '/api/Store/list';

      let queryParameters = new URLSearchParams();
      let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
      let body : string = '';

      // to determine the Accept header
      let produces: string[] = [ 'application/xml', 'application/json' ];
      headers.set('Content-Type', 'application/json');

      let requestOptions: RequestOptionsArgs = new RequestOptions({
       headers: headers,
       method: RequestMethod.Get,
       body:'',
       search: queryParameters,
       withCredentials: this.configuration.withCredentials
      });

      if (extraHttpRequestParams) {
         requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
      }
      return this.http.request(path, requestOptions);
   }

   public Read(application : String, name : String) : Observable<StoreServerData> {
      return this.Read_WithHttpInfo(application, name)
      .map((response: Response) =>  {
         if (response.status === 204) {
            return undefined;
         }
         else {
            return response.json() || { };
         }
      }
      );
   }
   private Read_WithHttpInfo(application : String, name : String, extraHttpRequestParams? : any) : Observable<Response> {

      const path = this.basePath + '/api/Store/read/{application}/{name}';

      let queryParameters = new URLSearchParams();
      let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
      let body : string = '';

      // to determine the Accept header
      let produces: string[] = [ 'application/xml', 'application/json' ];
      if (application !== undefined) {
         queryParameters.set('application', <any> application);
      }

      if (name !== undefined) {
         queryParameters.set('name', <any> name);
      }

      headers.set('Content-Type', 'application/json');

      let requestOptions: RequestOptionsArgs = new RequestOptions({
       headers: headers,
       method: RequestMethod.Get,
       body:'',
       search: queryParameters,
       withCredentials: this.configuration.withCredentials
      });

      if (extraHttpRequestParams) {
         requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
      }
      return this.http.request(path, requestOptions);
   }

   public Create(application : String, name : String) : Observable<{}> {
      return this.Create_WithHttpInfo(application, name)
      .map((response: Response) =>  {
         if (response.status === 204) {
            return undefined;
         }
         else {
            return response.json() || { };
         }
      }
      );
   }
   private Create_WithHttpInfo(application : String, name : String, extraHttpRequestParams? : any) : Observable<Response> {

      const path = this.basePath + '/api/Store/create/{application}/{name}';

      let queryParameters = new URLSearchParams();
      let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
      let body : string = '';

      // to determine the Accept header
      let produces: string[] = [ 'application/xml', 'application/json' ];
      if (application !== undefined) {
         queryParameters.set('application', <any> application);
      }

      if (name !== undefined) {
         queryParameters.set('name', <any> name);
      }

      headers.set('Content-Type', 'application/json');

      let requestOptions: RequestOptionsArgs = new RequestOptions({
       headers: headers,
       method: RequestMethod.Get,
       body:'',
       search: queryParameters,
       withCredentials: this.configuration.withCredentials
      });

      if (extraHttpRequestParams) {
         requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
      }
      return this.http.request(path, requestOptions);
   }

   public Update(application : String, lockid : String, item : StoreServerData) : Observable<{}> {
      return this.Update_WithHttpInfo(application, lockid, item)
      .map((response: Response) =>  {
         if (response.status === 204) {
            return undefined;
         }
         else {
            return response.json() || { };
         }
      }
      );
   }
   private Update_WithHttpInfo(application : String, lockid : String, item : StoreServerData, extraHttpRequestParams? : any) : Observable<Response> {

      const path = this.basePath + '/api/Store/update/{application}/{lockid}';

      let queryParameters = new URLSearchParams();
      let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
      let body : string = '';

      // to determine the Accept header
      let produces: string[] = [ 'application/xml', 'application/json' ];
      if (application !== undefined) {
         queryParameters.set('application', <any> application);
      }

      if (lockid !== undefined) {
         queryParameters.set('lockid', <any> lockid);
      }

      if (item !== undefined) {
         body = JSON.stringify(item);
      }

      headers.set('Content-Type', 'application/json');

      let requestOptions: RequestOptionsArgs = new RequestOptions({
       headers: headers,
       method: RequestMethod.Post,
       body: body == null ? '' : body, 
       search: queryParameters,
       withCredentials: this.configuration.withCredentials
      });

      if (extraHttpRequestParams) {
         requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
      }
      return this.http.request(path, requestOptions);
   }

   public Lock(application : String, name : String) : Observable<String> {
      return this.Lock_WithHttpInfo(application, name)
      .map((response: Response) =>  {
         if (response.status === 204) {
            return undefined;
         }
         else {
            return response.json() || { };
         }
      }
      );
   }
   private Lock_WithHttpInfo(application : String, name : String, extraHttpRequestParams? : any) : Observable<Response> {

      const path = this.basePath + '/api/Store/lock/{application}/{name}';

      let queryParameters = new URLSearchParams();
      let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
      let body : string = '';

      // to determine the Accept header
      let produces: string[] = [ 'application/xml', 'application/json' ];
      if (application !== undefined) {
         queryParameters.set('application', <any> application);
      }

      if (name !== undefined) {
         queryParameters.set('name', <any> name);
      }

      headers.set('Content-Type', 'application/json');

      let requestOptions: RequestOptionsArgs = new RequestOptions({
       headers: headers,
       method: RequestMethod.Get,
       body:'',
       search: queryParameters,
       withCredentials: this.configuration.withCredentials
      });

      if (extraHttpRequestParams) {
         requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
      }
      return this.http.request(path, requestOptions);
   }

   public UnLock(application : String, name : String, lockid : String) : Observable<{}> {
      return this.UnLock_WithHttpInfo(application, name, lockid)
      .map((response: Response) =>  {
         if (response.status === 204) {
            return undefined;
         }
         else {
            return response.json() || { };
         }
      }
      );
   }
   private UnLock_WithHttpInfo(application : String, name : String, lockid : String, extraHttpRequestParams? : any) : Observable<Response> {

      const path = this.basePath + '/api/Store/unlock/{application}/{name}/{lockid}';

      let queryParameters = new URLSearchParams();
      let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
      let body : string = '';

      // to determine the Accept header
      let produces: string[] = [ 'application/xml', 'application/json' ];
      if (application !== undefined) {
         queryParameters.set('application', <any> application);
      }

      if (name !== undefined) {
         queryParameters.set('name', <any> name);
      }

      if (lockid !== undefined) {
         queryParameters.set('lockid', <any> lockid);
      }

      headers.set('Content-Type', 'application/json');

      let requestOptions: RequestOptionsArgs = new RequestOptions({
       headers: headers,
       method: RequestMethod.Get,
       body:'',
       search: queryParameters,
       withCredentials: this.configuration.withCredentials
      });

      if (extraHttpRequestParams) {
         requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
      }
      return this.http.request(path, requestOptions);
   }

   public Delete(application : String, name : String, lockid : String) : Observable<{}> {
      return this.Delete_WithHttpInfo(application, name, lockid)
      .map((response: Response) =>  {
         if (response.status === 204) {
            return undefined;
         }
         else {
            return response.json() || { };
         }
      }
      );
   }
   private Delete_WithHttpInfo(application : String, name : String, lockid : String, extraHttpRequestParams? : any) : Observable<Response> {

      const path = this.basePath + '/api/Store/{application}/{name}/{lockid}';

      let queryParameters = new URLSearchParams();
      let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
      let body : string = '';

      // to determine the Accept header
      let produces: string[] = [ 'application/xml', 'application/json' ];
      if (application !== undefined) {
         queryParameters.set('application', <any> application);
      }

      if (name !== undefined) {
         queryParameters.set('name', <any> name);
      }

      if (lockid !== undefined) {
         queryParameters.set('lockid', <any> lockid);
      }

      headers.set('Content-Type', 'application/json');

      let requestOptions: RequestOptionsArgs = new RequestOptions({
       headers: headers,
       method: RequestMethod.Delete,
       body: '',
       search: queryParameters,
       withCredentials: this.configuration.withCredentials
      });

      if (extraHttpRequestParams) {
         requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
      }
      return this.http.request(path, requestOptions);
   }

}
